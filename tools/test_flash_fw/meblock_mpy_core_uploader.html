<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MEBLOCK • Upload Core (.py) via Serial (Folder → ROOT)</title>
  <style>
    :root{
      --bg:#0b0e14; --panel:#121826; --muted:#9aa4b2; --text:#e5e7eb;
      --brand:#4f46e5; --ok:#10b981; --warn:#f59e0b; --err:#ef4444; --border:#1f2937;
      --radius:16px; --shadow:0 10px 35px rgba(0,0,0,.25);
    }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(120deg,#0b0e14,#10131b);color:var(--text);
      font:14px/1.55 system-ui,Segoe UI,Roboto,Helvetica,Arial}
    header{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:18px 22px;
      position:sticky;top:0;background:rgba(11,14,20,.7);backdrop-filter:blur(6px);
      border-bottom:1px solid var(--border);z-index:10}
    header h1{font-size:16px;margin:0;font-weight:650;letter-spacing:.2px}
    .badge{font-size:11px;color:#9ca3af;border:1px solid var(--border);padding:2px 8px;border-radius:999px}
    .wrap{max-width:1100px;margin:22px auto;padding:0 16px 60px}
    .grid{display:grid;grid-template-columns:420px 1fr;gap:16px}
    @media (max-width:980px){.grid{grid-template-columns:1fr}}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow)}
    .sec{padding:16px}
    .sec h2{margin:0 0 12px;font-size:13px;letter-spacing:.4px;text-transform:uppercase;color:var(--muted)}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .tiny{font-size:12px;color:var(--muted)}
    label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px}
    input[type=text]{width:100%;background:#0f1422;color:var(--text);border:1px solid #263041;
      border-radius:12px;padding:10px 12px;outline:none}
    input[type=file]{width:100%}
    button{appearance:none;border:1px solid #2a3550;background:#192038;color:var(--text);
      padding:10px 14px;border-radius:12px;cursor:pointer}
    button.primary{background:var(--brand);border-color:transparent}
    button.good{background:#0b2d24;border-color:#0b2d24;color:#a7f3d0}
    button.warn{background:#2b2410;border-color:#2b2410;color:#fde68a}
    button.danger{background:#2b1618;border-color:#2b1618;color:#fecaca}
    button:disabled{opacity:.45;cursor:not-allowed}
    .status{display:flex;align-items:center;gap:8px}
    .dot{width:10px;height:10px;border-radius:999px;background:#6b7280}
    .dot.ok{background:var(--ok)}
    .dot.bad{background:var(--err)}
    .banner{background:#1f2937;color:#e5e7eb;border-left:4px solid var(--warn);padding:10px 12px;
      border-radius:8px;margin:0 0 12px}
    .log{background:#0a0f1a;border-top:1px solid var(--border);border-radius:0 0 var(--radius) var(--radius);
      max-height:420px;overflow:auto;padding:12px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
      white-space:pre-wrap}
    table{width:100%;border-collapse:separate;border-spacing:0 8px}
    th{color:var(--muted);text-align:left;font-weight:650;font-size:12px;padding:0 10px}
    td{background:#0f1422;border:1px solid #263041;padding:10px;border-left:0;border-right:0}
    tr td:first-child{border-left:1px solid #263041;border-radius:12px 0 0 12px}
    tr td:last-child{border-right:1px solid #263041;border-radius:0 12px 12px 0}
    progress{width:100%;height:12px}
    hr{border:0;border-top:1px solid var(--border);margin:14px 0}
    .hide{display:none !important}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:2px 10px;border-radius:999px;
      border:1px solid #263041;color:#cbd5e1;font-size:11px}
    .pill.ok{border-color:#0b2d24;color:#a7f3d0}
    .pill.err{border-color:#2b1618;color:#fecaca}
    .pill.run{border-color:#2a3550;color:#cbd5e1}
    code{font-size:12px}
  </style>
</head>
<body>
  <header>
    <div class="row">
      <h1>MEBLOCK • Upload Core MicroPython (.py) từ Folder → ROOT (/)</h1>
      <span class="badge">Web Serial • raw REPL • folder-only • overwrite</span>
    </div>
    <div class="status"><span id="connDot" class="dot"></span><span id="connLabel">Disconnected</span></div>
  </header>

  <div class="wrap">
    <div id="insecureBanner" class="banner hide">
      Web Serial cần chạy trên <b>HTTPS</b> hoặc <b>localhost</b>.
      Ví dụ: <code>python -m http.server 8000</code> rồi mở <code>http://localhost:8000</code>.
    </div>

    <div class="card">
      <div class="sec grid">
        <div>
          <h2>1) Kết nối Serial</h2>

          <label>Baud rate</label>
          <input id="baud" type="text" value="115200" />

          <div class="row" style="margin-top:10px">
            <button id="btnConnect" class="primary">Chọn cổng & Connect</button>
            <button id="btnDisconnect">Disconnect</button>
            <button id="btnStop" class="warn">Stop (CTRL-C)</button>
            <button id="btnReset" class="warn">Reset</button>
          </div>
          <div class="tiny">Windows: COMx • Linux/macOS: /dev/tty*</div>

          <hr/>

          <h2>2) Chọn core (.py)</h2>

          <label>Chọn thư mục core (.py) — sẽ nạp tất cả file .py vào ROOT (/) và ghi đè nếu trùng tên</label>
          <input id="pickFolder" type="file" webkitdirectory directory multiple />

          <div class="row" style="margin-top:10px">
            <label class="tiny" style="margin:0">
              <input type="checkbox" id="autoReset" checked style="vertical-align:middle;margin-right:6px">
              Auto reset sau khi nạp xong
            </label>
          </div>

          <div class="row" style="margin-top:10px">
            <label class="tiny" style="margin:0">
              Chunk size (bytes):
              <input id="chunkSize" type="text" value="1024" style="width:120px;margin-left:8px">
            </label>
          </div>

          <hr/>

          <h2>3) Flash</h2>
          <div class="row">
            <button id="btnFlash" class="good">Flash folder → ROOT</button>
            <button id="btnAbort" class="danger">Abort</button>
            <button id="btnClear" class="tiny" style="margin-left:auto">Clear log</button>
          </div>

          <label style="margin-top:14px">Overall progress</label>
          <progress id="progOverall" max="100" value="0"></progress>
          <div class="tiny" id="overallText">0 / 0 bytes</div>
        </div>

        <div>
          <h2>Danh sách file sẽ nạp</h2>
          <div class="tiny" id="filesHint">Chưa chọn file nào.</div>
          <div style="overflow:auto;max-height:420px">
            <table>
              <thead>
                <tr>
                  <th>Src</th>
                  <th>Dst (root)</th>
                  <th>Size</th>
                  <th>Status</th>
                  <th>Progress</th>
                </tr>
              </thead>
              <tbody id="fileTbody"></tbody>
            </table>
          </div>
        </div>
      </div>

      <div class="log" id="log"></div>
    </div>
  </div>

  <script type="module">
    class SerialMicroPythonREPL {
      constructor({ onLog = (t)=>console.log(t), onStatus = ()=>{}, paceMs = 3 } = {}) {
        this.onLog = onLog;
        this.onStatus = onStatus;
        this.paceMs = paceMs;
        this.port = null;
        this.reader = null;
        this.writer = null;
        this.enc = new TextEncoder();
        this.connected = false;
        this._readAbort = null;
        this._writeQueue = Promise.resolve();
        this._flashAbort = false;
      }
      _requireConnected(){ if(!this.connected || !this.port) throw new Error("Not connected"); }
      async _sleep(ms){ if(!ms||ms<=0) return; return new Promise(r=>setTimeout(r,ms)); }
      _log(t){ if(t) this.onLog(t); }

      async _startReadLoop(){
        if(!this.port) return;
        await this._stopReadLoop().catch(()=>{});
        this._readAbort = new AbortController();
        const signal = this._readAbort.signal;
        const reader = this.port.readable.getReader();
        this.reader = reader;
        const td = new TextDecoder();
        this._log("[ReadLoop] started.\n");
        (async ()=>{
          try{
            while(true){
              if(signal.aborted) break;
              const {value, done} = await reader.read();
              if(done) break;
              if(value) this._log(td.decode(value));
            }
          }catch(err){
            if(!signal.aborted) this._log(`[ReadLoop] error: ${err}\n`);
          }finally{
            try{ reader.releaseLock(); }catch{}
            if(this.reader===reader) this.reader=null;
            this._log("[ReadLoop] stopped.\n");
          }
        })();
      }

      async _stopReadLoop(){
        if(!this.reader) return;
        try{ this._readAbort?.abort(); }catch{}
        this._readAbort=null;
        try{ await this.reader.cancel(); }catch{}
        try{ this.reader.releaseLock(); }catch{}
        this.reader=null;
      }

      async connect({ baudRate = 115200 } = {}){
        if(!("serial" in navigator)) throw new Error("Web Serial API not available (use Chrome/Edge)");
        const port = await navigator.serial.requestPort({});
        await port.open({ baudRate });
        this.port = port;
        this.connected = true;
        this.writer = port.writable.getWriter();
        this.onStatus(true);
        this._log(`[Serial] Connected @${baudRate}.\n`);
        await this._startReadLoop();
      }

      async disconnect(){
        await this._stopReadLoop().catch(()=>{});
        try{ if(this.writer) await this.writer.close(); }catch{}
        try{ this.writer?.releaseLock(); }catch{}
        this.writer=null;
        try{ if(this.port) await this.port.close(); }catch{}
        this.port=null;
        this.connected=false;
        this.onStatus(false);
        this._log("[Serial] Disconnected.\n");
      }

      async _sendBytes(bytes, { chunkSize=128 } = {}){
        this._requireConnected();
        const w = this.writer;
        this._writeQueue = this._writeQueue.then(async ()=>{
          for(let i=0;i<bytes.length;i+=chunkSize){
            await w.write(bytes.slice(i, i+chunkSize));
            if(this.paceMs>0) await this._sleep(this.paceMs);
          }
        });
        return this._writeQueue;
      }
      _sendText(t){ return this._sendBytes(this.enc.encode(t)); }

      ctrlA(){ return this._sendBytes(Uint8Array.of(0x01)); }
      ctrlB(){ return this._sendBytes(Uint8Array.of(0x02)); }
      ctrlC(){ return this._sendBytes(Uint8Array.of(0x03)); }
      ctrlD(){ return this._sendBytes(Uint8Array.of(0x04)); }

      async enterRaw(){
        this._requireConnected();
        await this.ctrlC(); await this._sleep(40);
        await this.ctrlA(); await this._sleep(40);
      }

      async rawExec(pyCode){
        this._requireConnected();
        await this._sendText(pyCode);
        await this.ctrlD();
      }

      async stop(){ this._requireConnected(); this._log("[CTRL-C]\n"); await this.ctrlC(); }
      async reset(){
        this._requireConnected();
        this._log("[machine.reset()]\n");
        await this.enterRaw();
        await this.rawExec("import machine\nmachine.reset()\n");
      }

      abortFlash(){ this._flashAbort = true; }

      static base64FromBytes(bytes){
        let binary = "";
        const step = 0x8000;
        for(let i=0;i<bytes.length;i+=step){
          const sub = bytes.subarray(i, i+step);
          binary += String.fromCharCode.apply(null, sub);
        }
        return btoa(binary);
      }

      static pyQuote(s){
        return "'" + String(s).replace(/\\/g,"\\\\").replace(/'/g,"\\'") + "'";
      }

      async flashFiles(files, {
        dstResolver = (file)=>file?.name || "main.py",
        chunkSize = 1024,
        autoReset = true,
        onFileStart, onFileProgress, onFileDone, onFileError,
        onOverallProgress,
      } = {}){
        this._requireConnected();
        const arr = Array.from(files||[]).filter(f => f instanceof File);
        if(!arr.length) throw new Error("No files");
        this._flashAbort = false;

        const metas = arr.map(f => ({ file: f, size: f.size, dst: String(dstResolver(f) || f.name) }));
        const totalAll = metas.reduce((s,m)=>s+(m.size||0), 0);
        let sentAll = 0;

        this._log(`--- FLASH (${metas.length} files, ${totalAll} bytes) ---\n`);
        await this.enterRaw();

        const init =
          "import ubinascii, os\n" +
          "def __fw(p,b64,m):\n" +
          "    f=open(p,m)\n" +
          "    f.write(ubinascii.a2b_base64(b64))\n" +
          "    f.close()\n" +
          "def __ensuredir(path):\n" +
          "    try: path=str(path)\n" +
          "    except Exception: return\n" +
          "    if '/' not in path: return\n" +
          "    parts = path.split('/')\n" +
          "    cur = ''\n" +
          "    for p in parts[:-1]:\n" +
          "        if not p or p=='.':\n" +
          "            continue\n" +
          "        cur = (cur + '/' + p) if cur else p\n" +
          "        try: os.stat(cur)\n" +
          "        except Exception:\n" +
          "            try: os.mkdir(cur)\n" +
          "            except Exception: pass\n";
        await this.rawExec(init);

        for(let i=0;i<metas.length;i++){
          if(this._flashAbort) throw new Error("FLASH_ABORTED");
          const {file, size, dst} = metas[i];
          onFileStart?.({ index:i, totalFiles: metas.length, file, dst, size });
          this._log(`--- FILE ${i+1}/${metas.length}: ${file.name} -> ${dst} (${size} bytes) ---\n`);

          try{
            await this.rawExec(`__ensuredir(${SerialMicroPythonREPL.pyQuote(dst)})\n`);

            const bytes = new Uint8Array(await file.arrayBuffer());
            let written = 0;

            while(written < bytes.length){
              if(this._flashAbort) throw new Error("FLASH_ABORTED");
              const part = bytes.subarray(written, written + chunkSize);
              const b64 = SerialMicroPythonREPL.base64FromBytes(part);
              const mode = written === 0 ? "wb" : "ab";
              const stmt = `__fw(${SerialMicroPythonREPL.pyQuote(dst)}, ${SerialMicroPythonREPL.pyQuote(b64)}, ${SerialMicroPythonREPL.pyQuote(mode)})\n`;
              await this.rawExec(stmt);

              written += part.length;
              sentAll += part.length;

              onFileProgress?.({ index:i, file, dst, written, total: bytes.length });
              onOverallProgress?.({ written: sentAll, total: totalAll });

              await this._sleep(8);
            }

            onFileDone?.({ index:i, file, dst, size });
            this._log(`[OK] ${file.name} -> ${dst}\n`);
          }catch(err){
            onFileError?.({ index:i, file, dst, error: err });
            this._log(`[ERROR] ${file.name}: ${err}\n`);
            throw err;
          }
        }

        await this.rawExec("import os\ntry:\n    os.sync()\nexcept Exception:\n    pass\nprint('[FLASH_DONE]')\n");
        await this._sleep(150);

        if(autoReset){
          this._log("[AUTO RESET]\n");
          await this.rawExec("import machine\nmachine.reset()\n");
        }else{
          await this.ctrlB();
        }

        this._log("[DONE] Flash finished.\n");
      }
    }

    const $ = (sel)=>document.querySelector(sel);
    const logEl = $("#log");
    function log(t){
      const d = document.createElement("div");
      d.textContent = t;
      logEl.appendChild(d);
      logEl.scrollTop = logEl.scrollHeight;
    }
    function setConn(connected){
      $("#connDot").classList.toggle("ok", connected);
      $("#connDot").classList.toggle("bad", !connected);
      $("#connLabel").textContent = connected ? "Connected" : "Disconnected";
      $("#btnConnect").disabled = connected;
      $("#btnDisconnect").disabled = !connected;
      $("#btnStop").disabled = !connected;
      $("#btnReset").disabled = !connected;
      $("#btnFlash").disabled = !connected;
      $("#btnAbort").disabled = !connected;
    }
    if(!window.isSecureContext && location.hostname !== "localhost"){
      $("#insecureBanner").classList.remove("hide");
    }

    const repl = new SerialMicroPythonREPL({
      onLog: (t)=>log(t),
      onStatus: (ok)=>setConn(ok),
      paceMs: 3,
    });

    const state = { files: [], rows: new Map(), dstMap: new WeakMap(), totalBytes: 0 };

    function normalizePath(p){
      p = (p || "").replace(/\\/g,"/");
      p = p.replace(/\/+/g,"/");
      p = p.replace(/^\.\//,"");
      return p;
    }
    function baseNameFromPath(p){
      const s = normalizePath(p);
      const parts = s.split("/");
      return parts[parts.length - 1] || "main.py";
    }

    function fmtBytes(n){
      if(!Number.isFinite(n)) return "";
      if(n < 1024) return `${n} B`;
      if(n < 1024*1024) return `${(n/1024).toFixed(1)} KB`;
      return `${(n/1024/1024).toFixed(2)} MB`;
    }
    function uniqueFiles(list){
      const out = [];
      const seen = new Set();
      for(const f of list){
        const key = (f.webkitRelativePath || f.name) + "|" + f.size + "|" + f.lastModified;
        if(seen.has(key)) continue;
        seen.add(key);
        out.push(f);
      }
      return out;
    }
    function clearTable(){
      $("#fileTbody").innerHTML = "";
      state.rows.clear();
      state.dstMap = new WeakMap();
    }
    function setRowStatus(row, kind, text){
      const pill = row.querySelector("[data-pill]");
      pill.classList.remove("ok","err","run");
      pill.classList.add(kind);
      pill.textContent = text;
    }
    function setRowProgress(row, pct){
      row.querySelector("progress").value = Math.max(0, Math.min(100, pct));
    }
    function addFileRow(file, dst){
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${(file.webkitRelativePath || file.name)}</td>
        <td><code>/${dst}</code></td>
        <td>${fmtBytes(file.size)}</td>
        <td><span class="pill run" data-pill>Queued</span></td>
        <td><progress max="100" value="0"></progress></td>
      `;
      $("#fileTbody").appendChild(tr);
      state.rows.set(file, tr);
    }

    function rebuildFileList(){
      clearTable();

      // Folder-only → lấy .py, nạp vào ROOT (/) theo basename, ghi đè nếu trùng tên
      const files = state.files
        .filter(f => f.name.toLowerCase().endsWith(".py"))
        .map(f => {
          const src = normalizePath(f.webkitRelativePath ? f.webkitRelativePath : f.name);
          const dst = baseNameFromPath(src); // ROOT
          return { f, src, dst };
        })
        .sort((a,b)=>a.src.localeCompare(b.src, "en"));

      state.files = files.map(x=>x.f);
      state.totalBytes = state.files.reduce((s,f)=>s+f.size,0);

      $("#filesHint").textContent = state.files.length ? `${state.files.length} file(s)` : "Chưa chọn file nào.";

      for(const item of files){
        state.dstMap.set(item.f, item.dst);
        addFileRow(item.f, item.dst);
      }

      $("#progOverall").value = 0;
      $("#overallText").textContent = `0 / ${fmtBytes(state.totalBytes)}`;
    }

    $("#btnClear").addEventListener("click", ()=>{ logEl.innerHTML = ""; });

    $("#pickFolder").addEventListener("change", (e)=>{
      const picked = Array.from(e.target.files || []);
      state.files = uniqueFiles([...picked]); // folder-only
      rebuildFileList();
    });

    $("#btnConnect").addEventListener("click", async ()=>{
      try{
        const baudRate = parseInt($("#baud").value, 10) || 115200;
        await repl.connect({ baudRate });
      }catch(err){
        log(`[ERR] ${err?.message || err}\n`);
      }
    });
    $("#btnDisconnect").addEventListener("click", async ()=>{
      try{ await repl.disconnect(); }catch(err){ log(`[ERR] ${err?.message || err}\n`); }
    });
    $("#btnStop").addEventListener("click", async ()=>{
      try{ await repl.stop(); }catch(err){ log(`[ERR] ${err?.message || err}\n`); }
    });
    $("#btnReset").addEventListener("click", async ()=>{
      try{ await repl.reset(); }catch(err){ log(`[ERR] ${err?.message || err}\n`); }
    });
    $("#btnAbort").addEventListener("click", ()=>{
      repl.abortFlash();
      log("[ABORT] requested.\n");
    });

    $("#btnFlash").addEventListener("click", async ()=>{
      if(!repl.connected){ log("[WARN] Chưa connect.\n"); return; }
      if(!state.files.length){ log("[WARN] Chưa chọn thư mục.\n"); return; }

      const total = state.totalBytes;
      let sent = 0;

      for(const f of state.files){
        const row = state.rows.get(f);
        if(row){ setRowStatus(row, "run", "Queued"); setRowProgress(row, 0); }
      }
      $("#progOverall").value = 0;
      $("#overallText").textContent = `0 / ${fmtBytes(total)}`;

      const autoReset = $("#autoReset").checked;
      const chunkSize = Math.max(128, parseInt($("#chunkSize").value, 10) || 1024);

      try{
        await repl.flashFiles(state.files, {
          dstResolver: (file)=>state.dstMap.get(file) || file.name,
          chunkSize,
          autoReset,
          onFileProgress: ({file, written, total})=>{
            const row = state.rows.get(file);
            if(row){
              setRowStatus(row, "run", "Uploading");
              setRowProgress(row, total ? (written/total*100) : 0);
            }
          },
          onFileDone: ({file})=>{
            const row = state.rows.get(file);
            if(row){
              setRowStatus(row, "ok", "OK");
              setRowProgress(row, 100);
            }
            sent += file.size;
            $("#progOverall").value = total ? (sent/total*100) : 0;
            $("#overallText").textContent = `${fmtBytes(sent)} / ${fmtBytes(total)}`;
          },
          onFileError: ({file, error})=>{
            const row = state.rows.get(file);
            if(row) setRowStatus(row, "err", "ERR");
            log(`[FILE ERR] ${file.name}: ${error}\n`);
          },
        });

        log("\n[DONE] Upload finished.\n");
      }catch(err){
        log(`\n[ERR] ${err?.message || err}\n`);
      }
    });

    setConn(false);
  </script>
</body>
</html>
